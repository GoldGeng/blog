
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>JavaScript 常见问题和解决方式 | Hexo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="John Doe">
    
    <meta name="description" content="JavaScript 因其历史原因一直存在诸多缺陷，本文所讨论的只是其中的一小部分，适合为初学者答疑解惑，此外文中观点尚存在不足之处，或者对部分问题 ES6 已经提出了新的解决方案。

类型判断使用 typeof 运算符判断一个原始值变量的类型是没有问题的，但如果判断的是引用值类型就会有局限性，比如">
    
    
    
    
    
    <link rel="icon" href="/blog/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/blog/img/myLogo.png">
    <link rel="apple-touch-icon-precomposed" href="/blog/img/myLogo.png">
    

  
    <link href="/blog/css/font-awesome.min.css" rel="stylesheet">
    
  

    <link rel="stylesheet" href="/blog/css/style.css">
    <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?d182ed77fc48758bf45a33835ee35745";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

      <script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v1/st.js','_st');

  _st('install','.............Add your swiftype userID...............');
</script>
</head>

  <body>
    <header>
      <div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/blog/" title="Hexo">Hexo</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
                    <ul>
					 
						<li><a href="/blog">首页</a></li>
					
						<li><a href="/blog/archives">归档</a></li>
					
					<li>
					
					</li>
                <!--<li><div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div></li>-->

				</ul>
			</nav>	
</div>
    </header>
    <div id="container" class="clearfix">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/blog/2018/05/09/js/" title="JavaScript 常见问题和解决方式" itemprop="url">JavaScript 常见问题和解决方式</a>
  </h1>
  <p class="article-time">
    <time datetime="2018-05-09T07:46:03.000Z" itemprop="datePublished">2018-05-09</time>
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title"></strong>
		<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#类型判断"><span class="toc-number">1.</span> <span class="toc-text">类型判断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#局部变量泄漏到全局"><span class="toc-number">2.</span> <span class="toc-text">局部变量泄漏到全局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#立即执行函数"><span class="toc-number">3.</span> <span class="toc-text">立即执行函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#严格模式"><span class="toc-number">4.</span> <span class="toc-text">严格模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#浮点数的精度问题"><span class="toc-number">5.</span> <span class="toc-text">浮点数的精度问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setTimeout"><span class="toc-number">6.</span> <span class="toc-text">setTimeout</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-key"><span class="toc-number">7.</span> <span class="toc-text">Object key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#eval-作用域"><span class="toc-number">8.</span> <span class="toc-text">eval 作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#私有方法"><span class="toc-number">9.</span> <span class="toc-text">私有方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#delete-操作符"><span class="toc-number">10.</span> <span class="toc-text">delete 操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#延迟定义"><span class="toc-number">11.</span> <span class="toc-text">延迟定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#错误处理"><span class="toc-number">12.</span> <span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象属性"><span class="toc-number">13.</span> <span class="toc-text">对象属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#位运算和右结合"><span class="toc-number">14.</span> <span class="toc-text">位运算和右结合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Base64-编码"><span class="toc-number">15.</span> <span class="toc-text">Base64 编码</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#参考资料"><span class="toc-number">15.0.0.0.1.</span> <span class="toc-text">参考资料</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>
		</div>
		
		<p>JavaScript 因其历史原因一直存在诸多缺陷，本文所讨论的只是其中的一小部分，适合为初学者答疑解惑，此外文中观点尚存在不足之处，或者对部分问题 ES6 已经提出了新的解决方案。</p>
<p><a id="more"></a></p>
<h2 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a><a href="#类型判断" title="类型判断"></a>类型判断</h2><p>使用 typeof 运算符判断一个原始值变量的类型是没有问题的，但如果判断的是引用值类型就会有局限性，比如 <code>null</code> 和数组的结果都是 <code>object</code>。要想判断变量属于哪种内置类型，最靠谱的方式是调用 <code>Object.prototype.toString</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="built_in">Object</span>.prototype.toString.call([])</div><div class="line"><span class="comment">// =&gt; “[object Array]”</span></div></pre></td></tr></table></figure>

<p>在 JavaScript 规范（ECMA-262 19.1.3.6）中详细解释了 <code>Object.prototype.toString</code> 的解析过程：</p>
<ol>
<li>如果 <code>this</code> 的值为 <code>undefined</code>，则返回字符串 <code>&amp;quot;[object Undefined]&amp;quot;</code></li>
<li>如果 <code>this</code> 的值为 <code>null</code>，则返回字符串 <code>&amp;quot;[object Null]&amp;quot;</code></li>
<li>使用 <code>O</code> 表示 <code>ToObject(this)</code> 的值</li>
<li>使用 <code>isArray</code> 表示 <code>IsArray(O)</code> 的值</li>
<li>如果 <code>isArray</code> 不是正常值（比如抛出错误），则中断执行</li>
<li>如果 <code>isArray === true</code>，则 <code>builtinTag = &amp;quot;Array&amp;quot;</code>，之后执行第 16 步</li>
<li>如果 <code>O</code> 是一个 exotic 字符串对象，则 <code>builtinTag = &amp;quot;String&amp;quot;</code>，之后执行第 16 步</li>
<li>如果 <code>O</code> 拥有内部属性 <code>[[ParameterMap]]</code>，则 <code>builtinTag = &amp;quot;Arguments&amp;quot;</code>，跳到第 16 步</li>
<li>如果 <code>O</code> 拥有内部方法 <code>[[Call]]</code>，则 <code>builtinTag = &amp;quot;Function&amp;quot;</code>，跳到第 16 步</li>
<li>如果 <code>O</code> 拥有内部属性 <code>[[ErrorData]]</code>，则 <code>builtinTag = &amp;quot;Error&amp;quot;</code>，跳到第 16 步</li>
<li>如果 <code>O</code> 拥有内部属性 <code>[[BooleanData]]</code>，则 <code>builtinTag = &amp;quot;Boolean&amp;quot;</code>，跳到第 16 步</li>
<li>如果 <code>O</code> 拥有内部属性 <code>[[NumberData]]</code>，则 <code>builtinTag = &amp;quot;Number&amp;quot;</code>，跳到第 16 步</li>
<li>如果 <code>O</code> 拥有内部属性 <code>[[DateValue]]</code>，则 <code>builtinTag = &amp;quot;Date&amp;quot;</code>，跳到第 16 步</li>
<li>如果 <code>O</code> 拥有内部属性 <code>[[RegExpMather]]</code>，则 <code>builtinTag = &amp;quot;RegExp&amp;quot;</code>，跳到第 16 步</li>
<li>如果第 6 ~ 14 步都不符合，则 <code>builtinTag = &amp;quot;Object&amp;quot;</code>，跳到第 16 步</li>
<li>使用 <code>tag</code> 表示 <code>Get (O, @@toStringTag)</code> 的值</li>
<li>如果 <code>tag</code> 不是正常值，则中断执行</li>
<li>如果 <code>Type(tag)</code> 不是一个字符串，则 <code>tag = builtinTag</code></li>
<li>返回一个 <code>&amp;quot;[object&amp;quot; + tag + &amp;quot;]&amp;quot;</code> 形式的字符串<div class="tip"><br>开发者喜欢使用该方法获取内部属性 <code>[[Class]]</code> 的字符串值，用于检测内建对象的类型。值得注意的是，这一方法只对内建对象有效，对宿主对象等其他类型的对象则不具有可信度。<br></div>

</li>
</ol>
<h2 id="局部变量泄漏到全局"><a href="#局部变量泄漏到全局" class="headerlink" title="局部变量泄漏到全局"></a><a href="#局部变量泄漏到全局" title="局部变量泄漏到全局"></a>局部变量泄漏到全局</h2><p>有如下所示的代码，猜测一下输出结果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> a = b = <span class="number">3</span>;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line"><span class="built_in">console</span>.log(b);</div></pre></td></tr></table></figure>

<p>很多时候不经意间，某些变量就会泄漏为全局变量，比如这里的变量 b。上述代码等同于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    b = <span class="number">3</span>;</div><div class="line">    <span class="keyword">var</span> a = b;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>

<p>ES6 支持块级作用域，使用时需要遵循两个条件：一是添加 <code>&amp;quot;use strict;&amp;quot;</code> 字符串，声明严格模式；而是使用 <code>let</code> 和 <code>const</code> 声明变量。如果不能使用 ES6 的块级作用域，那么声明变量时要做到使用单独一行声明单个变量，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> b = <span class="number">3</span>;</div><div class="line"><span class="keyword">var</span> a = b;</div></pre></td></tr></table></figure>

<h2 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a><a href="#立即执行函数" title="立即执行函数"></a>立即执行函数</h2><p>使用立即执行函数的好处是模块化和块级作用域。目前 ES6 对这两个方面都有相应的支持，所以除非为了保持兼容性，ES6 会是更好的开发方式。</p>
<p>在浏览器环境中，立即调用函数中的 <code>this</code> 指向全局变量 <code>window</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>);</div><div class="line">    <span class="comment">// =&gt; true</span></div><div class="line">&#125;)();</div></pre></td></tr></table></figure>

<h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a><a href="#严格模式" title="严格模式"></a>严格模式</h2><ol>
<li>使用 <code>&amp;#39;use strict;&amp;#39;</code> 声明严格模式</li>
<li>全局变量必须显示声明</li>
<li>禁止使用 with 语句，限制动态绑定</li>
<li><code>eval()</code> 的作用域为独立作用域，独立于全局作用域和函数作用域之外，生成的变量只能用于 eval 内部</li>
<li>禁止 <code>this</code> 关键字指向全局对象</li>
<li>禁止使用 <code>delete</code> 删除变量，只有 <code>configurable === true</code> 的属性可以被删除</li>
<li>对可读属性赋值、对禁止扩展的对象添加属性、删除不可删除属性都会报错</li>
<li>禁止在对象中添加重名属性</li>
<li>不允许对 arguments 赋值</li>
<li>禁止使用 arguments.callee</li>
<li>必须在顶层作用域声明函数</li>
<li>新增保留字</li>
</ol>
<h2 id="浮点数的精度问题"><a href="#浮点数的精度问题" class="headerlink" title="浮点数的精度问题"></a><a href="#浮点数的精度问题" title="浮点数的精度问题"></a>浮点数的精度问题</h2><p>对于使用 IEEE 754 存储双精度 64 位浮点数的语言都会遇到这个问题，且最简单的复现方式就是计算 <code>0.1 + 0.2</code>。这一表达式的值不等于 <code>0.3</code>，其原因就是 IEEE 754 不能正确表示 0.1。IEEE 754 规定的浮点数由一位符号位 <code>s</code>、五十二位小数位 <code>m</code> 和十一位指数位组成 <code>e</code>：</p>
<p>$$s \times m \times 2^e$$</p>
<p>JavaScript 规定 e 的范围为 <code>[-1074, 971]</code>，则 <code>Number.MAX_VALUE</code> 的值为：</p>
<p>$$ 1 \times ( 2^{53} - 1) \times 2^{971} $$</p>
<p>了解以上基础知识后求取 <code>0.1</code> 和 <code>0.2</code> 的二进制表示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">(<span class="number">0.1</span>).toString(<span class="number">2</span>)</div><div class="line"><span class="comment">// =&gt; “0.0001100110011001100110011001100110011001100110011001101”</span></div><div class="line"></div><div class="line">(<span class="number">0.2</span>).toString(<span class="number">2</span>)</div><div class="line"><span class="comment">// =&gt; “0.001100110011001100110011001100110011001100110011001101”</span></div><div class="line"></div><div class="line">(<span class="number">0.1</span> + <span class="number">0.2</span>).toString(<span class="number">2</span>)</div><div class="line"><span class="comment">// =&gt; “0.0100110011001100110011001100110011001100110011001101”</span></div></pre></td></tr></table></figure>

<p>关于这一问题的详细解析和其他问题，建议参考文章：</p>
<ul>
<li><a href="http://www.cnblogs.com/zichi/p/5034201.html" target="_blank" rel="noopener">http://www.cnblogs.com/zichi/p/5034201.html</a></li>
<li><a href="http://www.cnblogs.com/zichi/p/5043540.html" target="_blank" rel="noopener">http://www.cnblogs.com/zichi/p/5043540.html</a></li>
</ul>
<h2 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a><a href="#setTimeout" title="setTimeout"></a>setTimeout</h2><p>JavaScript 是单线程语言，异步事件的优先级低于其他代码，<code>setTimeout(callback, 0)</code> 表示加入事件队列以异步的方式执行，且在事件队列中优先执行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>); </div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">2</span>)&#125;, <span class="number">1000</span>); </div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">3</span>)&#125;, <span class="number">0</span>); </div><div class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>

<h2 id="Object-key"><a href="#Object-key" class="headerlink" title="Object key"></a><a href="#Object-key" title="Object key"></a>Object key</h2><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> a=&#123;&#125;,</div><div class="line">    b=&#123;<span class="attr">key</span>:<span class="string">‘b’</span>&#125;,</div><div class="line">    c=&#123;<span class="attr">key</span>:<span class="string">‘c’</span>&#125;;</div><div class="line"> </div><div class="line">a[b]=<span class="number">123</span>;</div><div class="line">a[c]=<span class="number">456</span>;</div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log(a[b]);</div><div class="line"><span class="comment">// =&gt; 456</span></div></pre></td></tr></table></figure>

<p>上面的代码有一个特点，就是没有使用字符串或 Symbol 作为对象的属性名，所以系统会将其转换为字符串，相当于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">a[<span class="built_in">Object</span>.prototype.toString.call(b)]=<span class="number">123</span>;</div><div class="line">a[<span class="built_in">Object</span>.prototype.toString.call(c)]=<span class="number">456</span>;</div><div class="line"></div><div class="line"><span class="comment">// equal to</span></div><div class="line">a[<span class="string">“[object Object]”</span>]=<span class="number">123</span>;</div><div class="line">a[<span class="string">“[object Object]”</span>]=<span class="number">456</span>;</div></pre></td></tr></table></figure>

<h2 id="eval-作用域"><a href="#eval-作用域" class="headerlink" title="eval 作用域"></a><a href="#eval-作用域" title="eval 作用域"></a>eval 作用域</h2><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> y = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;&#125;) &#123;</div><div class="line">    y += <span class="keyword">typeof</span> f;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(y);</div><div class="line"><span class="comment">// =&gt; “1undefined”</span></div></pre></td></tr></table></figure>

<p>在上面的代码中，最奇怪的有点在于 <code>typeof f === &amp;quot;undefined&amp;quot;</code>。之所以有这样的结果，是因为 if 条件语句是使用 <code>eval()</code> 解析的。由于 <code>eval(function f(){})</code> 只会返回值而不会向全局作用域暴漏变量 <code>f</code>，所以执行 <code>typeof f</code> 时并没有找到函数 <code>f</code>，则值为 undefined。</p>
<h2 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a><a href="#私有方法" title="私有方法"></a>私有方法</h2><p>在 JavaScript 中模拟私有方法的缺点就是内存占用高：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> Employee = <span class="function"><span class="keyword">function</span> (<span class="params">name, company, salary</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name || <span class="string">“”</span>;       </div><div class="line">    <span class="keyword">this</span>.company = company || <span class="string">“”</span>; </div><div class="line">    <span class="keyword">this</span>.salary = salary || <span class="number">5000</span>; </div><div class="line"></div><div class="line">    <span class="comment">// Private method</span></div><div class="line">    <span class="keyword">var</span> increaseSalary = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.salary = <span class="keyword">this</span>.salary + <span class="number">1000</span>;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">// Public method</span></div><div class="line">    <span class="keyword">this</span>.dispalyIncreasedSalary = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        increaseSlary();</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.salary);</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> emp1 = <span class="keyword">new</span> Employee(<span class="string">“John”</span>,<span class="string">“Pluto”</span>,<span class="number">3000</span>);</div><div class="line"><span class="keyword">var</span> emp2 = <span class="keyword">new</span> Employee(<span class="string">“Merry”</span>,<span class="string">“Pluto”</span>,<span class="number">2000</span>);</div><div class="line"><span class="keyword">var</span> emp3 = <span class="keyword">new</span> Employee(<span class="string">“Ren”</span>,<span class="string">“Pluto”</span>,<span class="number">2500</span>);</div></pre></td></tr></table></figure>

<p>对于 <code>Employee</code> 的每一个实例 emp1 / emp2 / emp3，它们都拥有各自的一个 <code>increaseSalary</code> 方法，所以除非确有必要，尽量不要使用私有方法。</p>
<h2 id="delete-操作符"><a href="#delete-操作符" class="headerlink" title="delete 操作符"></a><a href="#delete-操作符" title="delete 操作符"></a>delete 操作符</h2><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> output = (<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</div><div class="line">    <span class="keyword">delete</span> x;</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;)(<span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(output);</div><div class="line"><span class="comment">// =&gt; 0</span></div></pre></td></tr></table></figure>

<p><code>delete</code> 操作符用于删除对象的属性，对于其他变量无效。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> Employee = &#123;</div><div class="line">  <span class="attr">company</span>: <span class="string">‘xyz’</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> emp1 = <span class="built_in">Object</span>.create(Employee);</div><div class="line"><span class="keyword">delete</span> emp1.company;</div><div class="line"><span class="built_in">console</span>.log(emp1.company);</div><div class="line"><span class="comment">// =&gt; “xyz”</span></div></pre></td></tr></table></figure>

<p>在上面的代码中，emp1 通过原形链继承了 <code>Employee</code> 的属性 <code>company</code>，emp1 本身并没有 <code>company</code> 属性，即 <code>emp1.company === emp1.__proto__.company</code>，所以 <code>delete</code> 操作是无效的。</p>
<h2 id="延迟定义"><a href="#延迟定义" class="headerlink" title="延迟定义"></a><a href="#延迟定义" title="延迟定义"></a>延迟定义</h2><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 第一种声明方式</span></div><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </div><div class="line">    <span class="comment">// Some code</span></div><div class="line">&#125;; </div><div class="line"></div><div class="line"><span class="comment">// 第二种声明方式</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123; </div><div class="line">    <span class="comment">// Some code</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>

<p>这两种声明方式的差异在于，<code>foo()</code> 在运行时定义，而 <code>bar()</code> 在解析时定义。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">foo();</div><div class="line"><span class="comment">// 执行 foo() 时，foo 的值为 undefined</span></div><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </div><div class="line">    <span class="built_in">console</span>.log(<span class="string">“Hi I am inside Foo”</span>);</div><div class="line">&#125;; </div><div class="line"></div><div class="line">bar();</div><div class="line"><span class="comment">// 执行 bar() 时，由于 bar() 已经被 JavaScript 引擎解析过了，所以不会报错</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123; </div><div class="line">    <span class="built_in">console</span>.log(<span class="string">“Hi I am inside Foo”</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>

<p>根据这一特点，我们可以根据需要延迟定义某些功能：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span>(testCondition) &#123; </div><div class="line">    <span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </div><div class="line">        <span class="built_in">console</span>.log(<span class="string">“inside Foo with testCondition True value”</span>);</div><div class="line">    &#125;; </div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">    <span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </div><div class="line">        <span class="built_in">console</span>.log(<span class="string">“inside Foo with testCondition false value”</span>);</div><div class="line">    &#125;; </div><div class="line">&#125;</div></pre></td></tr></table></figure>

<p>在上面的代码中，布尔值 <code>testCondition</code> 决定了是定义何种功能的 <code>foo()</code> 函数，在定义之前，<code>foo</code> 只是一个原始值 <code>undefined</code>，并没有引用具体的函数。</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a><a href="#错误处理" title="错误处理"></a>错误处理</h2><p>当 JavaScript 解析或运行发生错误时，系统会抛出一个 Error 对象的实例，该实例包含 name、message 和 stack 三个属性，分别表示错误名称、错误提示信息和错误堆栈跟踪信息。</p>
<p>JavaScript 中存在六种原生错误类型：</p>
<ul>
<li>URIError: URI 错误</li>
<li>TypeError: 类型错误</li>
<li>RangeError: 越界错误</li>
<li>SyntaxError: 语法错误</li>
<li>ReferenceError: 引用错误</li>
<li>EvalError: evel() 执行错误</li>
</ul>
<p>错误捕获语句：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 尝试捕获异常</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">‘Error is out!’</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 捕获异常后执行该分支</span></div><div class="line"><span class="keyword">catch</span> (e) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string"><code>&lt;span class=&quot;subst&quot;&gt;$&amp;#123;e.name&amp;#125;&lt;/span&gt;: &lt;span class=&quot;subst&quot;&gt;$&amp;#123;e.message&amp;#125;&lt;/span&gt;</code></span>);</div><div class="line">    <span class="built_in">console</span>.log(e.stack);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 无论是否存在异常都执行该分支</span></div><div class="line"><span class="keyword">finally</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">‘Error is captured!’</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 典型应用：读写文件</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    writeFile(Data);</div><div class="line">&#125; </div><div class="line"><span class="keyword">catch</span>(e) &#123;</div><div class="line">    handleError(e);</div><div class="line">&#125; </div><div class="line"><span class="keyword">finally</span> &#123;</div><div class="line">    closeFile();</div><div class="line">&#125;</div></pre></td></tr></table></figure>

<h2 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a><a href="#对象属性" title="对象属性"></a>对象属性</h2><ul>
<li><code>Object.kyes(obj)</code>，以数组的形式返回 <code>obj</code> 对象的所有属性</li>
<li><code>key in obj</code>，检查 <code>obj</code> 对象中是否存在 <code>key</code> 属性，存在就返回 <code>true</code>，否则返回 <code>false</code></li>
<li><code>for (var key in obj)</code>，遍历 <code>obj</code> 对象的全部属性，该对象必须 enumberable</li>
<li><code>obj.hasOwnProperty(key)</code>，判断 <code>key</code> 是否是 <code>obj</code> 对象本身的属性，而不是继承来的属性</li>
</ul>
<h2 id="位运算和右结合"><a href="#位运算和右结合" class="headerlink" title="位运算和右结合"></a><a href="#位运算和右结合" title="位运算和右结合"></a>位运算和右结合</h2><p>位运算是对二进制位的直接计算，在 JavaScript 中进行位运算需要注意的是，由于其使用浮点数保存数值，所以数值执行位运算前会被转换为 32 位带符号的整数，最终的返回值也是一个 32 位的带符号整数，所以这种取整方法不适用超过 32 位带符号整数的最大值 2^31。一共有七种位运算：</p>
<ul>
<li><code>|</code>，或运算</li>
<li><code>&amp;amp;</code>，与运算</li>
<li><code>~</code>，否运算</li>
<li><code>^</code>，异或运算</li>
<li><code>&amp;lt;&amp;lt;</code>，左移运算，将一个整数的二进制向左移动，尾部补 0，相当于乘二操作</li>
<li><code>&amp;gt;&amp;gt;</code>，右移运算，将一个整数的二进制向右移动，正数头部补 0，负数头部补 1，相当于除二操作</li>
<li><code>&amp;gt;&amp;gt;&amp;gt;</code>，带符号右移运算，将一个整数的二进制向右移动，正负数头部一律补 0<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="number">4</span> &lt;&lt; <span class="number">1</span></div><div class="line"><span class="comment">// =&gt; 8</span></div><div class="line"></div><div class="line"><span class="number">4</span> &gt;&gt; <span class="number">1</span></div><div class="line"><span class="comment">// =&gt; 2</span></div><div class="line"></div><div class="line"><span class="number">-4</span> &gt;&gt; <span class="number">1</span></div><div class="line"><span class="comment">// =&gt; 2</span></div></pre></td></tr></table></figure>

</li>
</ul>
<p>大部分运算符是左结合的，但赋值运算符和三元运算符则是右结合的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">w = x = y = z;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line">w = (x = (y = z));</div><div class="line"></div><div class="line">q = a ? b : c ? d : e ? f : g;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line">q = (a ? b : (c ? d: (e ? f : g)));</div></pre></td></tr></table></figure>

<h2 id="Base64-编码"><a href="#Base64-编码" class="headerlink" title="Base64 编码"></a><a href="#Base64-编码" title="Base64 编码"></a>Base64 编码</h2><p>JavaScript 原生提供了两个和 Base64 编码相关的方法：</p>
<ul>
<li><code>window.atob()</code>，将 Base64 转换为 ASCII 编码</li>
<li><code>window.btoa()</code>，将 ASCII 转换为 Base64 编码</li>
</ul>
<p>此外，对于要转换为 Base64 的非 ASCII 编码，可以使用 <code>encodeURIComponent()</code> 方法进行预处理：</p>
<p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="built_in">window</span>.btoa(<span class="built_in">encodeURIComponent</span>(<span class="string">‘<a href="http://pinggod.com~&#39;" target="_blank" rel="noopener">http://pinggod.com~&#39;</a></span>));</div><div class="line"><span class="comment">// =&gt; “aHR0cCUzQSUyRiUyRnBpbmdnb2QuY29tfg==”</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>RFC-2396 将 URI 中的字符分为三类：<br>一类是保留字符，包括 <code>;</code>、<code>/</code>、<code>?</code>、<code>:</code>、<code>@</code>、<code>&amp;amp;</code>、<code>=</code>、<code>+</code>、<code>$</code>、<code>,</code>；<br>一类是 Mark 字符，包括 <code>-</code>、<code>_</code>、<code>.</code>、<code>!</code>、<code>~</code>、<code>*</code>、<code>&amp;#39;</code>、<code>(</code>、<code>)</code>；<br>一类是基本字符，包括数字和大小写字母。<br><code>encodeURI()</code> 和 <code>encodeURIComponent()</code> 的不同之处就在于，前者不会处理保留字符。</p>
</blockquote>
<h6 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><a href="#参考资料" title="参考资料"></a>参考资料</h6><ul>
<li><a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">http://es6.ruanyifeng.com/</a></li>
<li><a href="http://javascript.ruanyifeng.com/" target="_blank" rel="noopener">http://javascript.ruanyifeng.com/</a></li>
<li><a href="https://www.toptal.com/javascript/interview-questions" target="_blank" rel="noopener">25 Essential JavaScript Interview Questions</a></li>
<li><a href="https://www.codementor.io/javascript/tutorial/21-essential-javascript-tech-interview-practice-questions-answers" target="_blank" rel="noopener">21 Essential JavaScript Tech Interview Practive Questions answers</a></li>
</ul>
  
	</div>
		<footer class="article-footer clearfix">




<div class="article-share" id="share">

  <div data-url="http://yoursite.com/2018/05/09/js/" data-title="JavaScript 常见问题和解决方式 | Hexo" data-tsina="" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/blog/2018/05/09/gaoxingnenng/" title="读《高性能网站建设指南》">
  <strong>New:</strong><br/>
  <span>
  读《高性能网站建设指南》</span>
</a>
</div>


<div class="next">
<a href="/blog/2018/05/09/xingneng/"  title="性能优化的十二个方面">
 <strong>Old:</strong><br/> 
 <span>性能优化的十二个方面
</span>
</a>
</div>

</nav>

	
<section class="comment">
	
	<div class="ds-thread" data-title="JavaScript 常见问题和解决方式" data-thread-key="js" data-author-key="John Doe" data-url="http://yoursite.com/post/js"></div>
	
</section>


</div>  
    </div>
    <footer><div id="footer" >
	<div class="copyright">
		<span>Powered by <a href="https://github.com/hexojs/hexo">Hexo</a> and theme by 
		<a href="https://github.com/levonlin/Tinnypp">Tinnypp</a>.</span>
		
			<span>© GoldGeng</span>
		
	<div>
</div></footer>
    <script src="/blog/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  //back to top
  function backToTop(){
    var buttonHTML = $("<a href=\"#top\" id=\"back-top\">" + "<span>Back to Top</span></a>");
    buttonHTML.appendTo($("body"));
    var buttonToTop = $("#back-top");
    // hide #back-top first
    buttonToTop.hide();

    // fade in #back-top
    $(function() {
        $(window).scroll(function() {
            if ($(this).scrollTop() > 200) {
                buttonToTop.fadeIn();
            } else {
                buttonToTop.fadeOut();
            }
        });
        // scroll body to 0px on click
        buttonToTop.click(function() {
            $('body,html').animate({
                scrollTop: 0
            }, 800);
            return false;
        });
    });
  }
  backToTop();

  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      ta = $('#toc.toc-aside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
        
    }
  });

  var show = true;
  c.click(function(){
    if(show == true){
        a.addClass('fadeOut').css('display', 'none');
        ta.css('display', 'block').addClass('fadeIn');
        m.addClass('moveMain');  
    }else{
        a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');     
        ta.css('display', 'none'); 
        m.removeClass('moveMain');
        $('#toc.toc-aside').css('display', 'none');
    }
    show = !show;
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{

    $(window).scroll(function(){
      ta.css("top",Math.max(140,240-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>


<script type="text/javascript">
  var duoshuoQuery = {short_name:"tinnypp"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';    //change to ds.src = '/blog/js/embed.js'; to add useragent for duoshuo
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 



<link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/blog/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>

<script type="text/javascript">
  function footerPosition() {
    var contentHeight = document.documentElement.scrollHeight,
        winHeight = window.innerHeight;
    if(contentHeight <= winHeight) {
      $('footer').addClass('fixed-bottom');
    } else {
      $('footer').removeClass('fixed-bottom');
    }
  }
  footerPosition();
  $(window).resize(footerPosition);
</script>


  </body>
</html>
